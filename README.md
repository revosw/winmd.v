With this project, you can generate bindings to the Windows API for the V programming language.

# Setting up
Before you run `v run src`, you will need to run the `./setup.ps1` script. The script will:
1. Download [Microsoft.Windows.SDK.Win32Metadata from nuget](https://www.nuget.org/packages/Microsoft.Windows.SDK.Win32Metadata/), unpack it, move the `.winmd` file out of the extracted folder, and delete the zip file
2. Download [Microsoft.Windows.SDK.Win32Docs from nuget](https://www.nuget.org/packages/Microsoft.Windows.SDK.Win32Docs/), unpack it, move the `apidocs.msgpack` file out of the extracted folder, and delete the zip file
3. Generate a JSON file from the msgpack file using python. I have yet to figure out how to use the V implementation of [msgpack](https://vpm.vlang.io/packages/msgpack) for this, so that I can skip the conversion to JSON.

You can now run `v run src` to build the projection.

# Motivation
All useful programs running on Windows eventually require calling into the Windows kernel. This means your program must link to some Windows library at a binary level, and include an associated C header file at a source level. To make use of the included structs and functions defined in Windows' C header files, you must redeclare these symbols in a `.v.c` file.

This is a manual process spanning thousands of structs and functions across the entire Windows API. Automating this collectively saves an enormous amount of manual labor across the V ecosystem.

# Current plans
I plan on implementing two different sources of Windows metadata. One source is the json emitted by [win32json](https://github.com/marlersoft/win32json). This is the easiest way to consume the metadata. The other alternative is to parse the [winmd files](https://www.nuget.org/packages/Microsoft.Windows.SDK.Win32Metadata) generated by [win32metadata](https://github.com/microsoft/win32metadata).

The pros and cons of win32json:
- ðŸŸ© Way simpler implementation
- ðŸŸ© Cross platform
- ðŸŸ¨ Might not always be 100% up to date with [win32metadata](https://github.com/microsoft/win32metadata)

The pros and cons of using the [metadata API](https://learn.microsoft.com/en-us/windows/win32/api/rometadataapi/):
- ðŸŸ© Always up to date with [win32metadata](https://github.com/microsoft/win32metadata)
- ðŸŸ¨ Windows only. **Generating** the bindings is Windows only, **using** it is cross plaform

The pros and cons of rolling my own WinMD parser:
- ðŸŸ© Always up to date with [win32metadata](https://github.com/microsoft/win32metadata)
- ðŸŸ© Cross platform
- ðŸŸ© Basis for other community projects such as .NET interop
- ðŸŸ§ Vastly more time consuming

# What is a winmd file?
Microsoft currently uses [ClangSharp](https://github.com/microsoft/win32metadata#clangsharp-overview) to scrape Windows C headers, outputting an `.idl` file in C# (or more specifically, [ecma-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/) compliant code). The C# output is then further compiled to a common language runtime (CLR) assembly, which is the final step. You now have a `.winmd` file.

## Using the metadata API
Loading and reading winmd files is done with the [metadata API](https://learn.microsoft.com/en-us/windows/win32/api/rometadataapi/). If you're not familiar with COM, read both the [official documentation](https://learn.microsoft.com/en-us/windows/win32/com/the-component-object-model) and a [deep-dive article on COM in plain C](https://www.codeproject.com/Articles/13601/COM-in-plain-C). If you're not familiar with the CLR and the CLR assembly file format, read the [official documentation](https://learn.microsoft.com/en-us/dotnet/standard/clr) and see the links in further reading further down in this readme

Instead of using `CoCreateInstance` directly, there is a factory function [`MetaDataGetDispenser`](https://learn.microsoft.com/en-us/windows/win32/api/rometadata/nf-rometadata-metadatagetdispenser) we can use to kick things off. With the dispenser, we use `OpenScope` to open a winmd file, specifying either `IID_IMetaDataTables2`, `IID_IMetaDataImport2` or `IID_IMetaDataAssemblyImport` as the interface.

# Roadmap
Check the [milestones](https://github.com/revosw/winmd.v/milestones). I'll try to update the milestones with new issues to reflect the progress. 

# Further reading
- [Anatomy of a .NET Assembly â€“ CLR metadata 1](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-clr-metadata-1/)
- [Anatomy of a .NET Assembly â€“ CLR metadata 2](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-clr-metadata-2/)
- [Anatomy of a .NET Assembly â€“ CLR metadata 3](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-clr-metadata-3/)
- [Anatomy of a .NET Assembly â€“ Methods](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-methods/)
- [Anatomy of a .NET Assembly â€“ PE Headers](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-pe-headers/)
- [Anatomy of a .NET Assembly â€“ Signature encodings](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-signature-encodings/)
- [Anatomy of a .NET Assembly â€“ Custom attribute encoding](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-custom-attribute-encoding/)
- [Anatomy of a .NET Assembly â€“ Type forwards](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-type-forwards/)
- [Anatomy of a .NET Assembly â€“ The CLR Loader stub](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-the-clr-loader-stub/)
- [Anatomy of a .NET Assembly â€“ The DOS stub](https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-the-dos-stub/)